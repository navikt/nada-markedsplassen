// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dataset_access.sql

package gensql

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAccessToDataset = `-- name: GetAccessToDataset :one
SELECT access_id, access_subject, access_owner, access_granter, access_expires, access_created, access_revoked, access_dataset_id, access_request_id, access_platform, access_request_owner, access_request_subject, access_request_last_modified, access_request_created, access_request_expires, access_request_status, access_request_closed, access_request_granter, access_request_reason, polly_id, polly_name, polly_url, polly_external_id
FROM dataset_access_view
WHERE access_id = $1
`

func (q *Queries) GetAccessToDataset(ctx context.Context, id uuid.UUID) (DatasetAccessView, error) {
	row := q.db.QueryRowContext(ctx, getAccessToDataset, id)
	var i DatasetAccessView
	err := row.Scan(
		&i.AccessID,
		&i.AccessSubject,
		&i.AccessOwner,
		&i.AccessGranter,
		&i.AccessExpires,
		&i.AccessCreated,
		&i.AccessRevoked,
		&i.AccessDatasetID,
		&i.AccessRequestID,
		&i.AccessPlatform,
		&i.AccessRequestOwner,
		&i.AccessRequestSubject,
		&i.AccessRequestLastModified,
		&i.AccessRequestCreated,
		&i.AccessRequestExpires,
		&i.AccessRequestStatus,
		&i.AccessRequestClosed,
		&i.AccessRequestGranter,
		&i.AccessRequestReason,
		&i.PollyID,
		&i.PollyName,
		&i.PollyUrl,
		&i.PollyExternalID,
	)
	return i, err
}

const getActiveAccessToDatasetForSubject = `-- name: GetActiveAccessToDatasetForSubject :one
SELECT access_id, access_subject, access_owner, access_granter, access_expires, access_created, access_revoked, access_dataset_id, access_request_id, access_platform, access_request_owner, access_request_subject, access_request_last_modified, access_request_created, access_request_expires, access_request_status, access_request_closed, access_request_granter, access_request_reason, polly_id, polly_name, polly_url, polly_external_id
FROM dataset_access_view
WHERE access_dataset_id = $1 
AND access_subject = $2 
AND access_revoked IS NULL 
AND (
  access_expires IS NULL 
  OR access_expires >= NOW()
)
AND access_platform = $3
`

type GetActiveAccessToDatasetForSubjectParams struct {
	DatasetID uuid.UUID
	Subject   string
	Platform  string
}

func (q *Queries) GetActiveAccessToDatasetForSubject(ctx context.Context, arg GetActiveAccessToDatasetForSubjectParams) (DatasetAccessView, error) {
	row := q.db.QueryRowContext(ctx, getActiveAccessToDatasetForSubject, arg.DatasetID, arg.Subject, arg.Platform)
	var i DatasetAccessView
	err := row.Scan(
		&i.AccessID,
		&i.AccessSubject,
		&i.AccessOwner,
		&i.AccessGranter,
		&i.AccessExpires,
		&i.AccessCreated,
		&i.AccessRevoked,
		&i.AccessDatasetID,
		&i.AccessRequestID,
		&i.AccessPlatform,
		&i.AccessRequestOwner,
		&i.AccessRequestSubject,
		&i.AccessRequestLastModified,
		&i.AccessRequestCreated,
		&i.AccessRequestExpires,
		&i.AccessRequestStatus,
		&i.AccessRequestClosed,
		&i.AccessRequestGranter,
		&i.AccessRequestReason,
		&i.PollyID,
		&i.PollyName,
		&i.PollyUrl,
		&i.PollyExternalID,
	)
	return i, err
}

const getUserAccesses = `-- name: GetUserAccesses :many
SELECT dsa.access_id, dsa.access_subject, dsa.access_owner, dsa.access_granter, dsa.access_expires, dsa.access_created, dsa.access_revoked, dsa.access_dataset_id, dsa.access_request_id, dsa.access_platform, dsa.access_request_owner, dsa.access_request_subject, dsa.access_request_last_modified, dsa.access_request_created, dsa.access_request_expires, dsa.access_request_status, dsa.access_request_closed, dsa.access_request_granter, dsa.access_request_reason, dsa.polly_id, dsa.polly_name, dsa.polly_url, dsa.polly_external_id,
    dp.id AS dataproduct_id,
    dp.name as dataproduct_name,
    dp.description as dataproduct_description,
    dp.slug as dataproduct_slug,
    dp.group as dataproduct_group,
    ds.id as dataset_id,
    ds.name as dataset_name,
    ds.description as dataset_description,
    ds.slug as dataset_slug
FROM dataset_access_view dsa 
    JOIN datasets ds on dsa.access_dataset_id = ds.id
    JOIN dataproducts dp on ds.dataproduct_id = dp.id
WHERE (dsa.access_subject = ANY($1::TEXT[]) OR dsa.access_owner = ANY($2::TEXT[]))
  AND dsa.access_revoked IS NULL
  AND (dsa.access_expires > NOW() OR dsa.access_expires IS NULL)
ORDER BY
    dsa.access_created DESC
`

type GetUserAccessesParams struct {
	Subjects []string
	Owners   []string
}

type GetUserAccessesRow struct {
	AccessID                  uuid.UUID
	AccessSubject             string
	AccessOwner               string
	AccessGranter             string
	AccessExpires             sql.NullTime
	AccessCreated             time.Time
	AccessRevoked             sql.NullTime
	AccessDatasetID           uuid.UUID
	AccessRequestID           uuid.NullUUID
	AccessPlatform            string
	AccessRequestOwner        sql.NullString
	AccessRequestSubject      sql.NullString
	AccessRequestLastModified sql.NullTime
	AccessRequestCreated      sql.NullTime
	AccessRequestExpires      sql.NullTime
	AccessRequestStatus       NullAccessRequestStatusType
	AccessRequestClosed       sql.NullTime
	AccessRequestGranter      sql.NullString
	AccessRequestReason       sql.NullString
	PollyID                   uuid.NullUUID
	PollyName                 sql.NullString
	PollyUrl                  sql.NullString
	PollyExternalID           sql.NullString
	DataproductID             uuid.UUID
	DataproductName           string
	DataproductDescription    sql.NullString
	DataproductSlug           string
	DataproductGroup          string
	DatasetID                 uuid.UUID
	DatasetName               string
	DatasetDescription        sql.NullString
	DatasetSlug               string
}

func (q *Queries) GetUserAccesses(ctx context.Context, arg GetUserAccessesParams) ([]GetUserAccessesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserAccesses, pq.Array(arg.Subjects), pq.Array(arg.Owners))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserAccessesRow{}
	for rows.Next() {
		var i GetUserAccessesRow
		if err := rows.Scan(
			&i.AccessID,
			&i.AccessSubject,
			&i.AccessOwner,
			&i.AccessGranter,
			&i.AccessExpires,
			&i.AccessCreated,
			&i.AccessRevoked,
			&i.AccessDatasetID,
			&i.AccessRequestID,
			&i.AccessPlatform,
			&i.AccessRequestOwner,
			&i.AccessRequestSubject,
			&i.AccessRequestLastModified,
			&i.AccessRequestCreated,
			&i.AccessRequestExpires,
			&i.AccessRequestStatus,
			&i.AccessRequestClosed,
			&i.AccessRequestGranter,
			&i.AccessRequestReason,
			&i.PollyID,
			&i.PollyName,
			&i.PollyUrl,
			&i.PollyExternalID,
			&i.DataproductID,
			&i.DataproductName,
			&i.DataproductDescription,
			&i.DataproductSlug,
			&i.DataproductGroup,
			&i.DatasetID,
			&i.DatasetName,
			&i.DatasetDescription,
			&i.DatasetSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const grantAccessToDataset = `-- name: GrantAccessToDataset :exec
INSERT INTO dataset_access (dataset_id,
                            "subject",
                            "owner",
                            granter,
                            expires,
                            access_request_id,
                            platform)
VALUES ($1,
        $2,
        $3,
        LOWER($4),
        $5,
        $6,
        $7)
`

type GrantAccessToDatasetParams struct {
	DatasetID       uuid.UUID
	Subject         string
	Owner           string
	Granter         string
	Expires         sql.NullTime
	AccessRequestID uuid.NullUUID
	Platform        string
}

func (q *Queries) GrantAccessToDataset(ctx context.Context, arg GrantAccessToDatasetParams) error {
	_, err := q.db.ExecContext(ctx, grantAccessToDataset,
		arg.DatasetID,
		arg.Subject,
		arg.Owner,
		arg.Granter,
		arg.Expires,
		arg.AccessRequestID,
		arg.Platform,
	)
	return err
}

const listAccessToDataset = `-- name: ListAccessToDataset :many
SELECT access_id, access_subject, access_owner, access_granter, access_expires, access_created, access_revoked, access_dataset_id, access_request_id, access_platform, access_request_owner, access_request_subject, access_request_last_modified, access_request_created, access_request_expires, access_request_status, access_request_closed, access_request_granter, access_request_reason, polly_id, polly_name, polly_url, polly_external_id
FROM dataset_access_view
WHERE access_dataset_id = $1
`

func (q *Queries) ListAccessToDataset(ctx context.Context, datasetID uuid.UUID) ([]DatasetAccessView, error) {
	rows, err := q.db.QueryContext(ctx, listAccessToDataset, datasetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DatasetAccessView{}
	for rows.Next() {
		var i DatasetAccessView
		if err := rows.Scan(
			&i.AccessID,
			&i.AccessSubject,
			&i.AccessOwner,
			&i.AccessGranter,
			&i.AccessExpires,
			&i.AccessCreated,
			&i.AccessRevoked,
			&i.AccessDatasetID,
			&i.AccessRequestID,
			&i.AccessPlatform,
			&i.AccessRequestOwner,
			&i.AccessRequestSubject,
			&i.AccessRequestLastModified,
			&i.AccessRequestCreated,
			&i.AccessRequestExpires,
			&i.AccessRequestStatus,
			&i.AccessRequestClosed,
			&i.AccessRequestGranter,
			&i.AccessRequestReason,
			&i.PollyID,
			&i.PollyName,
			&i.PollyUrl,
			&i.PollyExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveAccessToDataset = `-- name: ListActiveAccessToDataset :many
SELECT access_id, access_subject, access_owner, access_granter, access_expires, access_created, access_revoked, access_dataset_id, access_request_id, access_platform, access_request_owner, access_request_subject, access_request_last_modified, access_request_created, access_request_expires, access_request_status, access_request_closed, access_request_granter, access_request_reason, polly_id, polly_name, polly_url, polly_external_id
FROM dataset_access_view
WHERE access_dataset_id = $1 AND access_revoked IS NULL AND (access_expires IS NULL OR access_expires >= NOW())
`

func (q *Queries) ListActiveAccessToDataset(ctx context.Context, datasetID uuid.UUID) ([]DatasetAccessView, error) {
	rows, err := q.db.QueryContext(ctx, listActiveAccessToDataset, datasetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DatasetAccessView{}
	for rows.Next() {
		var i DatasetAccessView
		if err := rows.Scan(
			&i.AccessID,
			&i.AccessSubject,
			&i.AccessOwner,
			&i.AccessGranter,
			&i.AccessExpires,
			&i.AccessCreated,
			&i.AccessRevoked,
			&i.AccessDatasetID,
			&i.AccessRequestID,
			&i.AccessPlatform,
			&i.AccessRequestOwner,
			&i.AccessRequestSubject,
			&i.AccessRequestLastModified,
			&i.AccessRequestCreated,
			&i.AccessRequestExpires,
			&i.AccessRequestStatus,
			&i.AccessRequestClosed,
			&i.AccessRequestGranter,
			&i.AccessRequestReason,
			&i.PollyID,
			&i.PollyName,
			&i.PollyUrl,
			&i.PollyExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnrevokedExpiredAccessEntries = `-- name: ListUnrevokedExpiredAccessEntries :many
SELECT access_id, access_subject, access_owner, access_granter, access_expires, access_created, access_revoked, access_dataset_id, access_request_id, access_platform, access_request_owner, access_request_subject, access_request_last_modified, access_request_created, access_request_expires, access_request_status, access_request_closed, access_request_granter, access_request_reason, polly_id, polly_name, polly_url, polly_external_id
FROM dataset_access_view
WHERE access_revoked IS NULL
  AND access_expires < NOW()
`

func (q *Queries) ListUnrevokedExpiredAccessEntries(ctx context.Context) ([]DatasetAccessView, error) {
	rows, err := q.db.QueryContext(ctx, listUnrevokedExpiredAccessEntries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DatasetAccessView{}
	for rows.Next() {
		var i DatasetAccessView
		if err := rows.Scan(
			&i.AccessID,
			&i.AccessSubject,
			&i.AccessOwner,
			&i.AccessGranter,
			&i.AccessExpires,
			&i.AccessCreated,
			&i.AccessRevoked,
			&i.AccessDatasetID,
			&i.AccessRequestID,
			&i.AccessPlatform,
			&i.AccessRequestOwner,
			&i.AccessRequestSubject,
			&i.AccessRequestLastModified,
			&i.AccessRequestCreated,
			&i.AccessRequestExpires,
			&i.AccessRequestStatus,
			&i.AccessRequestClosed,
			&i.AccessRequestGranter,
			&i.AccessRequestReason,
			&i.PollyID,
			&i.PollyName,
			&i.PollyUrl,
			&i.PollyExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeAccessToDataset = `-- name: RevokeAccessToDataset :exec
UPDATE dataset_access
SET revoked = NOW()
WHERE id = $1
`

func (q *Queries) RevokeAccessToDataset(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, revokeAccessToDataset, id)
	return err
}
