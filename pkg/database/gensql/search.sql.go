// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: search.sql

package gensql

import (
	"context"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const search = `-- name: Search :many
SELECT
	element_id::uuid,
	element_type::text,
	ts_rank_cd(tsv_document, query) AS rank,
	ts_headline('norwegian', "description", query, 'MinWords=10, MaxWords=20, MaxFragments=2 FragmentDelimiter=" â€¦ " StartSel="((START))" StopSel="((STOP))"')::text AS excerpt
FROM
	search,
	websearch_to_tsquery('norwegian', $1) query
WHERE
	(
		CASE
			WHEN array_length($2::text[], 1) > 0 THEN "element_type" = ANY($2)
			ELSE TRUE
		END
	)
	AND (
		CASE
			WHEN array_length($3::text[], 1) > 0 THEN "keywords" && $3
			ELSE TRUE
		END
	)
	AND (
		CASE
			WHEN $1 :: text != '' THEN "tsv_document" @@ query
			ELSE TRUE
		END
	)
	AND (
		CASE
			WHEN array_length($4::text[], 1) > 0 THEN "group" = ANY($4)
			ELSE TRUE
		END
	)
	AND (
		CASE
			WHEN array_length($5::uuid[], 1) > 0 THEN "team_id" = ANY($5)
			ELSE TRUE
		END
	)
ORDER BY rank DESC, created ASC
LIMIT $7 OFFSET $6
`

type SearchParams struct {
	Query   string
	Types   []string
	Keyword []string
	Grp     []string
	TeamID  []uuid.UUID
	Offs    int32
	Lim     int32
}

type SearchRow struct {
	ElementID   uuid.UUID
	ElementType string
	Rank        float32
	Excerpt     string
}

func (q *Queries) Search(ctx context.Context, arg SearchParams) ([]SearchRow, error) {
	rows, err := q.db.QueryContext(ctx, search,
		arg.Query,
		pq.Array(arg.Types),
		pq.Array(arg.Keyword),
		pq.Array(arg.Grp),
		pq.Array(arg.TeamID),
		arg.Offs,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchRow{}
	for rows.Next() {
		var i SearchRow
		if err := rows.Scan(
			&i.ElementID,
			&i.ElementType,
			&i.Rank,
			&i.Excerpt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDatasets = `-- name: SearchDatasets :many
SELECT
	ds.id, ds.name, ds.description, ds.pii, ds.created, ds.last_modified, ds.type, ds.tsv_document, ds.slug, ds.repo, ds.keywords, ds.dataproduct_id, ds.anonymisation_description, ds.target_user
FROM
	datasets AS ds
	LEFT JOIN datasource_bigquery AS bq ON bq.dataset_id = ds.id
WHERE
 	$1 ILIKE ANY(ARRAY[ds.name, bq.project_id, bq.dataset, bq.table_name])
	OR concat_ws(
		'.',
		bq.project_id,
		bq.dataset,
		bq.table_name
	) ILIKE $1
	OR concat_ws(
		'.',
		bq.project_id,
		bq.dataset
	) ILIKE $1
	OR concat_ws(
		'.',
		bq.dataset,
		bq.table_name
	) ILIKE $1
`

func (q *Queries) SearchDatasets(ctx context.Context, keyword string) ([]Dataset, error) {
	rows, err := q.db.QueryContext(ctx, searchDatasets, keyword)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Dataset{}
	for rows.Next() {
		var i Dataset
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Pii,
			&i.Created,
			&i.LastModified,
			&i.Type,
			&i.TsvDocument,
			&i.Slug,
			&i.Repo,
			pq.Array(&i.Keywords),
			&i.DataproductID,
			&i.AnonymisationDescription,
			&i.TargetUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
