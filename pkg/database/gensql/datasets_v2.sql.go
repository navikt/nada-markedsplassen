// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: datasets_v2.sql

package gensql

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const getAccessibleDatasets = `-- name: GetAccessibleDatasets :many
SELECT
  DISTINCT ON (ds.id)
  ds.id, ds.name, ds.description, ds.pii, ds.created, ds.last_modified, ds.type, ds.tsv_document, ds.slug, ds.repo, ds.keywords, ds.dataproduct_id, ds.anonymisation_description, ds.target_user,
  dsa.subject AS "subject",
  dsa.owner AS "access_owner",
  dp.slug AS dp_slug,
  dp.name AS dp_name,
  dp.group
FROM
  datasets ds
  LEFT JOIN dataproducts dp ON ds.dataproduct_id = dp.id
  LEFT JOIN dataset_access dsa ON dsa.dataset_id = ds.id
WHERE
  array_length($1::TEXT[], 1) IS NOT NULL AND array_length($1::TEXT[], 1)!=0
  AND dp.group = ANY($1 :: TEXT [])
  OR (
    SPLIT_PART(dsa.subject, ':', 1) != 'serviceAccount'
    AND (
        $2::TEXT IS NOT NULL
        AND dsa.subject = LOWER($2)
        OR SPLIT_PART(dsa.subject, ':', 2) = ANY($1::TEXT[])
    )
  )
  AND revoked IS NULL
  AND (
    expires > NOW()
    OR expires IS NULL
  )
ORDER BY
  ds.id,
  ds.last_modified DESC
`

type GetAccessibleDatasetsParams struct {
	Groups    []string
	Requester string
}

type GetAccessibleDatasetsRow struct {
	ID                       uuid.UUID
	Name                     string
	Description              sql.NullString
	Pii                      PiiLevel
	Created                  time.Time
	LastModified             time.Time
	Type                     DatasourceType
	TsvDocument              interface{}
	Slug                     string
	Repo                     sql.NullString
	Keywords                 []string
	DataproductID            uuid.UUID
	AnonymisationDescription sql.NullString
	TargetUser               sql.NullString
	Subject                  sql.NullString
	AccessOwner              sql.NullString
	DpSlug                   sql.NullString
	DpName                   sql.NullString
	Group                    sql.NullString
}

func (q *Queries) GetAccessibleDatasets(ctx context.Context, arg GetAccessibleDatasetsParams) ([]GetAccessibleDatasetsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAccessibleDatasets, pq.Array(arg.Groups), arg.Requester)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAccessibleDatasetsRow{}
	for rows.Next() {
		var i GetAccessibleDatasetsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Pii,
			&i.Created,
			&i.LastModified,
			&i.Type,
			&i.TsvDocument,
			&i.Slug,
			&i.Repo,
			pq.Array(&i.Keywords),
			&i.DataproductID,
			&i.AnonymisationDescription,
			&i.TargetUser,
			&i.Subject,
			&i.AccessOwner,
			&i.DpSlug,
			&i.DpName,
			&i.Group,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAccessibleDatasetsByOwnedServiceAccounts = `-- name: GetAccessibleDatasetsByOwnedServiceAccounts :many
SELECT
  ds.id, ds.name, ds.description, ds.pii, ds.created, ds.last_modified, ds.type, ds.tsv_document, ds.slug, ds.repo, ds.keywords, ds.dataproduct_id, ds.anonymisation_description, ds.target_user,
  dsa.subject AS "subject",
  dsa.owner AS "access_owner",
  dp.slug AS dp_slug,
  dp.name AS dp_name,
  dp.group
FROM
  datasets ds
  LEFT JOIN dataproducts dp ON ds.dataproduct_id = dp.id
  LEFT JOIN dataset_access dsa ON dsa.dataset_id = ds.id
WHERE
  SPLIT_PART("subject", ':', 1) = 'serviceAccount'
  AND (
    dsa.owner = $1
    OR dsa.owner = ANY($2::TEXT[])
  )  
  AND revoked IS NULL
  AND (
    expires > NOW()
    OR expires IS NULL
  )
ORDER BY
  ds.last_modified DESC
`

type GetAccessibleDatasetsByOwnedServiceAccountsParams struct {
	Requester string
	Groups    []string
}

type GetAccessibleDatasetsByOwnedServiceAccountsRow struct {
	ID                       uuid.UUID
	Name                     string
	Description              sql.NullString
	Pii                      PiiLevel
	Created                  time.Time
	LastModified             time.Time
	Type                     DatasourceType
	TsvDocument              interface{}
	Slug                     string
	Repo                     sql.NullString
	Keywords                 []string
	DataproductID            uuid.UUID
	AnonymisationDescription sql.NullString
	TargetUser               sql.NullString
	Subject                  sql.NullString
	AccessOwner              sql.NullString
	DpSlug                   sql.NullString
	DpName                   sql.NullString
	Group                    sql.NullString
}

func (q *Queries) GetAccessibleDatasetsByOwnedServiceAccounts(ctx context.Context, arg GetAccessibleDatasetsByOwnedServiceAccountsParams) ([]GetAccessibleDatasetsByOwnedServiceAccountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAccessibleDatasetsByOwnedServiceAccounts, arg.Requester, pq.Array(arg.Groups))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAccessibleDatasetsByOwnedServiceAccountsRow{}
	for rows.Next() {
		var i GetAccessibleDatasetsByOwnedServiceAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Pii,
			&i.Created,
			&i.LastModified,
			&i.Type,
			&i.TsvDocument,
			&i.Slug,
			&i.Repo,
			pq.Array(&i.Keywords),
			&i.DataproductID,
			&i.AnonymisationDescription,
			&i.TargetUser,
			&i.Subject,
			&i.AccessOwner,
			&i.DpSlug,
			&i.DpName,
			&i.Group,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDatasetsMinimal = `-- name: GetAllDatasetsMinimal :many
SELECT ds.id, ds.created, name, project_id, dataset, table_name 
FROM datasets ds 
JOIN datasource_bigquery dsb 
ON ds.id = dsb.dataset_id
`

type GetAllDatasetsMinimalRow struct {
	ID        uuid.UUID
	Created   time.Time
	Name      string
	ProjectID string
	Dataset   string
	TableName string
}

func (q *Queries) GetAllDatasetsMinimal(ctx context.Context) ([]GetAllDatasetsMinimalRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllDatasetsMinimal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllDatasetsMinimalRow{}
	for rows.Next() {
		var i GetAllDatasetsMinimalRow
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Name,
			&i.ProjectID,
			&i.Dataset,
			&i.TableName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatasetComplete = `-- name: GetDatasetComplete :many
SELECT
  dp_group, ds_id, ds_name, ds_description, ds_created, ds_last_modified, ds_slug, pii, ds_keywords, ds_repo, ds_target_user, bq_id, bq_created, bq_last_modified, bq_expires, bq_description, bq_missing_since, pii_tags, bq_project, bq_dataset, bq_table_name, bq_table_type, pseudo_columns, bq_schema, ds_dp_id, mapping_services, mb_database_id, mb_deleted_at
FROM
  dataset_view
WHERE
  ds_id = $1
`

func (q *Queries) GetDatasetComplete(ctx context.Context, id uuid.UUID) ([]DatasetView, error) {
	rows, err := q.db.QueryContext(ctx, getDatasetComplete, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DatasetView{}
	for rows.Next() {
		var i DatasetView
		if err := rows.Scan(
			&i.DpGroup,
			&i.DsID,
			&i.DsName,
			&i.DsDescription,
			&i.DsCreated,
			&i.DsLastModified,
			&i.DsSlug,
			&i.Pii,
			pq.Array(&i.DsKeywords),
			&i.DsRepo,
			&i.DsTargetUser,
			&i.BqID,
			&i.BqCreated,
			&i.BqLastModified,
			&i.BqExpires,
			&i.BqDescription,
			&i.BqMissingSince,
			&i.PiiTags,
			&i.BqProject,
			&i.BqDataset,
			&i.BqTableName,
			&i.BqTableType,
			pq.Array(&i.PseudoColumns),
			&i.BqSchema,
			&i.DsDpID,
			pq.Array(&i.MappingServices),
			&i.MbDatabaseID,
			&i.MbDeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatasetCompleteWithAccess = `-- name: GetDatasetCompleteWithAccess :many
SELECT
  dp_group, ds_id, ds_name, ds_description, ds_created, ds_last_modified, ds_slug, pii, ds_keywords, ds_repo, ds_target_user, bq_id, bq_created, bq_last_modified, bq_expires, bq_description, bq_missing_since, pii_tags, bq_project, bq_dataset, bq_table_name, bq_table_type, pseudo_columns, bq_schema, ds_dp_id, mapping_services, mb_database_id, mb_deleted_at, access_id, access_subject, access_owner, access_granter, access_expires, access_created, access_revoked, access_dataset_id, access_request_id, access_request_owner, access_request_subject, access_request_last_modified, access_request_created, access_request_expires, access_request_status, access_request_closed, access_request_granter, access_request_reason, polly_id, polly_name, polly_url, polly_external_id
FROM
  dataset_view dv
LEFT JOIN dataset_access_view da ON da.access_dataset_id = $1 AND (
    dp_group = ANY($2::TEXT[])
    OR (
        SPLIT_PART(da.access_subject, ':', 2) = ANY($2::TEXT[])
        AND da.access_revoked IS NULL
))
WHERE
  ds_id = $1
`

type GetDatasetCompleteWithAccessParams struct {
	ID     uuid.UUID
	Groups []string
}

type GetDatasetCompleteWithAccessRow struct {
	DpGroup                   sql.NullString
	DsID                      uuid.UUID
	DsName                    string
	DsDescription             sql.NullString
	DsCreated                 time.Time
	DsLastModified            time.Time
	DsSlug                    string
	Pii                       PiiLevel
	DsKeywords                []string
	DsRepo                    sql.NullString
	DsTargetUser              sql.NullString
	BqID                      uuid.UUID
	BqCreated                 time.Time
	BqLastModified            time.Time
	BqExpires                 sql.NullTime
	BqDescription             sql.NullString
	BqMissingSince            sql.NullTime
	PiiTags                   pqtype.NullRawMessage
	BqProject                 string
	BqDataset                 string
	BqTableName               string
	BqTableType               string
	PseudoColumns             []string
	BqSchema                  pqtype.NullRawMessage
	DsDpID                    uuid.UUID
	MappingServices           []string
	MbDatabaseID              sql.NullInt32
	MbDeletedAt               sql.NullTime
	AccessID                  uuid.NullUUID
	AccessSubject             sql.NullString
	AccessOwner               sql.NullString
	AccessGranter             sql.NullString
	AccessExpires             sql.NullTime
	AccessCreated             sql.NullTime
	AccessRevoked             sql.NullTime
	AccessDatasetID           uuid.NullUUID
	AccessRequestID           uuid.NullUUID
	AccessRequestOwner        sql.NullString
	AccessRequestSubject      sql.NullString
	AccessRequestLastModified sql.NullTime
	AccessRequestCreated      sql.NullTime
	AccessRequestExpires      sql.NullTime
	AccessRequestStatus       NullAccessRequestStatusType
	AccessRequestClosed       sql.NullTime
	AccessRequestGranter      sql.NullString
	AccessRequestReason       sql.NullString
	PollyID                   uuid.NullUUID
	PollyName                 sql.NullString
	PollyUrl                  sql.NullString
	PollyExternalID           sql.NullString
}

func (q *Queries) GetDatasetCompleteWithAccess(ctx context.Context, arg GetDatasetCompleteWithAccessParams) ([]GetDatasetCompleteWithAccessRow, error) {
	rows, err := q.db.QueryContext(ctx, getDatasetCompleteWithAccess, arg.ID, pq.Array(arg.Groups))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDatasetCompleteWithAccessRow{}
	for rows.Next() {
		var i GetDatasetCompleteWithAccessRow
		if err := rows.Scan(
			&i.DpGroup,
			&i.DsID,
			&i.DsName,
			&i.DsDescription,
			&i.DsCreated,
			&i.DsLastModified,
			&i.DsSlug,
			&i.Pii,
			pq.Array(&i.DsKeywords),
			&i.DsRepo,
			&i.DsTargetUser,
			&i.BqID,
			&i.BqCreated,
			&i.BqLastModified,
			&i.BqExpires,
			&i.BqDescription,
			&i.BqMissingSince,
			&i.PiiTags,
			&i.BqProject,
			&i.BqDataset,
			&i.BqTableName,
			&i.BqTableType,
			pq.Array(&i.PseudoColumns),
			&i.BqSchema,
			&i.DsDpID,
			pq.Array(&i.MappingServices),
			&i.MbDatabaseID,
			&i.MbDeletedAt,
			&i.AccessID,
			&i.AccessSubject,
			&i.AccessOwner,
			&i.AccessGranter,
			&i.AccessExpires,
			&i.AccessCreated,
			&i.AccessRevoked,
			&i.AccessDatasetID,
			&i.AccessRequestID,
			&i.AccessRequestOwner,
			&i.AccessRequestSubject,
			&i.AccessRequestLastModified,
			&i.AccessRequestCreated,
			&i.AccessRequestExpires,
			&i.AccessRequestStatus,
			&i.AccessRequestClosed,
			&i.AccessRequestGranter,
			&i.AccessRequestReason,
			&i.PollyID,
			&i.PollyName,
			&i.PollyUrl,
			&i.PollyExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
