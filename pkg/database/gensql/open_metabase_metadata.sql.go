// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: open_metabase_metadata.sql

package gensql

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createOpenMetabaseMetadata = `-- name: CreateOpenMetabaseMetadata :exec
INSERT INTO open_metabase_metadata (
    "dataset_id"
) VALUES (
    $1
)
`

func (q *Queries) CreateOpenMetabaseMetadata(ctx context.Context, datasetID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, createOpenMetabaseMetadata, datasetID)
	return err
}

const deleteOpenMetabaseMetadata = `-- name: DeleteOpenMetabaseMetadata :exec
DELETE 
FROM open_metabase_metadata
WHERE "dataset_id" = $1
`

func (q *Queries) DeleteOpenMetabaseMetadata(ctx context.Context, datasetID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteOpenMetabaseMetadata, datasetID)
	return err
}

const getAllOpenMetabaseMetadata = `-- name: GetAllOpenMetabaseMetadata :many
SELECT dataset_id, database_id, deleted_at, sync_completed
FROM open_metabase_metadata
`

func (q *Queries) GetAllOpenMetabaseMetadata(ctx context.Context) ([]OpenMetabaseMetadatum, error) {
	rows, err := q.db.QueryContext(ctx, getAllOpenMetabaseMetadata)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OpenMetabaseMetadatum{}
	for rows.Next() {
		var i OpenMetabaseMetadatum
		if err := rows.Scan(
			&i.DatasetID,
			&i.DatabaseID,
			&i.DeletedAt,
			&i.SyncCompleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOpenMetabaseMetadata = `-- name: GetOpenMetabaseMetadata :one
SELECT dataset_id, database_id, deleted_at, sync_completed
FROM open_metabase_metadata
WHERE "dataset_id" = $1 AND "deleted_at" IS NULL
`

func (q *Queries) GetOpenMetabaseMetadata(ctx context.Context, datasetID uuid.UUID) (OpenMetabaseMetadatum, error) {
	row := q.db.QueryRowContext(ctx, getOpenMetabaseMetadata, datasetID)
	var i OpenMetabaseMetadatum
	err := row.Scan(
		&i.DatasetID,
		&i.DatabaseID,
		&i.DeletedAt,
		&i.SyncCompleted,
	)
	return i, err
}

const getOpenMetabaseMetadataWithDeleted = `-- name: GetOpenMetabaseMetadataWithDeleted :one
SELECT dataset_id, database_id, deleted_at, sync_completed
FROM open_metabase_metadata
WHERE "dataset_id" = $1
`

func (q *Queries) GetOpenMetabaseMetadataWithDeleted(ctx context.Context, datasetID uuid.UUID) (OpenMetabaseMetadatum, error) {
	row := q.db.QueryRowContext(ctx, getOpenMetabaseMetadataWithDeleted, datasetID)
	var i OpenMetabaseMetadatum
	err := row.Scan(
		&i.DatasetID,
		&i.DatabaseID,
		&i.DeletedAt,
		&i.SyncCompleted,
	)
	return i, err
}

const getOpenMetabaseTablesInSameBigQueryDataset2 = `-- name: GetOpenMetabaseTablesInSameBigQueryDataset2 :many
WITH sources_in_same_dataset AS (
  SELECT dataset_id, project_id, dataset, table_name, schema, last_modified, created, expires, table_type, description, pii_tags, missing_since, id, is_reference, pseudo_columns, deleted FROM datasource_bigquery 
  WHERE project_id = $1 AND dataset = $2
)

SELECT table_name FROM sources_in_same_dataset sds
JOIN open_metabase_metadata mbm
ON mbm.dataset_id = sds.dataset_id
WHERE mbm.permission_group_id = 0
`

type GetOpenMetabaseTablesInSameBigQueryDataset2Params struct {
	ProjectID string
	Dataset   string
}

func (q *Queries) GetOpenMetabaseTablesInSameBigQueryDataset2(ctx context.Context, arg GetOpenMetabaseTablesInSameBigQueryDataset2Params) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getOpenMetabaseTablesInSameBigQueryDataset2, arg.ProjectID, arg.Dataset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var table_name string
		if err := rows.Scan(&table_name); err != nil {
			return nil, err
		}
		items = append(items, table_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDatabaseOpenMetabaseMetadata = `-- name: SetDatabaseOpenMetabaseMetadata :one
UPDATE open_metabase_metadata
SET "database_id" = $1
WHERE dataset_id = $2
RETURNING dataset_id, database_id, deleted_at, sync_completed
`

type SetDatabaseOpenMetabaseMetadataParams struct {
	DatabaseID sql.NullInt32
	DatasetID  uuid.UUID
}

func (q *Queries) SetDatabaseOpenMetabaseMetadata(ctx context.Context, arg SetDatabaseOpenMetabaseMetadataParams) (OpenMetabaseMetadatum, error) {
	row := q.db.QueryRowContext(ctx, setDatabaseOpenMetabaseMetadata, arg.DatabaseID, arg.DatasetID)
	var i OpenMetabaseMetadatum
	err := row.Scan(
		&i.DatasetID,
		&i.DatabaseID,
		&i.DeletedAt,
		&i.SyncCompleted,
	)
	return i, err
}

const setSyncCompletedOpenMetabaseMetadata = `-- name: SetSyncCompletedOpenMetabaseMetadata :exec
UPDATE open_metabase_metadata
SET "sync_completed" = NOW()
WHERE dataset_id = $1
`

func (q *Queries) SetSyncCompletedOpenMetabaseMetadata(ctx context.Context, datasetID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, setSyncCompletedOpenMetabaseMetadata, datasetID)
	return err
}
