// Code generated by tygo. DO NOT EDIT.

//////////
// source: access.go

export type AccessStorage = any;
export type AccessService = any;
export interface Access {
  id: string /* uuid */;
  subject: string;
  owner: string;
  granter: string;
  expires?: string /* RFC3339 */;
  created: string /* RFC3339 */;
  revoked?: string /* RFC3339 */;
  datasetID: string /* uuid */;
  accessRequest?: AccessRequest;
}
export interface NewAccessRequestDTO {
  datasetID: string /* uuid */;
  subject?: string;
  subjectType?: string;
  owner?: string;
  expires?: string /* RFC3339 */;
  polly?: PollyInput;
}
export interface UpdateAccessRequestDTO {
  id: string /* uuid */;
  owner: string;
  expires?: string /* RFC3339 */;
  polly?: PollyInput;
}
export interface AccessRequest {
  id: string /* uuid */;
  datasetID: string /* uuid */;
  subject: string;
  subjectType: string;
  created: string /* RFC3339 */;
  status: AccessRequestStatus;
  closed?: string /* RFC3339 */;
  expires?: string /* RFC3339 */;
  granter?: string;
  owner: string;
  polly?: Polly;
  reason?: string;
}
export interface AccessRequestForGranter extends AccessRequest {
  dataproductID: string /* uuid */;
  dataproductSlug: string;
  datasetName: string;
  dataproductName: string;
}
export interface AccessRequestsWrapper {
  accessRequests: AccessRequest[];
}
export const SubjectTypeUser: string = "user";
export const SubjectTypeGroup: string = "group";
export const SubjectTypeServiceAccount: string = "serviceAccount";
export interface GrantAccessData {
  datasetID: string /* uuid */;
  expires?: string /* RFC3339 */;
  subject?: string;
  owner?: string;
  subjectType?: string;
}
export type AccessRequestStatus = string;
export const AccessRequestStatusPending: AccessRequestStatus = "pending";
export const AccessRequestStatusApproved: AccessRequestStatus = "approved";
export const AccessRequestStatusDenied: AccessRequestStatus = "denied";

//////////
// source: artifactregistry.go

export const ArtifactRegistryReaderRole = "roles/artifactregistry.reader";
export const ArtifactTypeKnastIndex = "application/vnd.knast.docs.index";
export const ArtifactTypeKnastAnnotations = "application/vnd.knast.annotations";
export type ArtifactRegistryAPI = any;
export interface ContainerRepositoryIdentifier {
  Project: string;
  Location: string;
  Repository: string;
}
export interface ContainerImage {
  Name: string;
  URI: string;
  Manifest?: Manifest;
  Documentation: string;
}
export interface Manifest {
  Labels: { [key: string]: string};
}
export interface Annotations {
  source: string;
  title: string;
  description: string;
}

//////////
// source: bigquery.go

export type BigQueryStorage = any;
export type BigQueryAPI = any;
export type BigQueryService = any;
export type BigQueryTableType = string;
/**
 * RegularTable is a regular table.
 */
export const RegularTable: BigQueryTableType = "TABLE";
/**
 * ViewTable is a table type describing that the table is a logical view.
 * See more information at https://cloud.google.com//docs/views.
 */
export const ViewTable: BigQueryTableType = "VIEW";
/**
 * ExternalTable is a table type describing that the table is an external
 * table (also known as a federated data source). See more information at
 * https://cloud.google.com/bigquery/external-data-sources.
 */
export const ExternalTable: BigQueryTableType = "EXTERNAL";
/**
 * MaterializedView represents a managed storage table that's derived from
 * a base table.
 */
export const MaterializedView: BigQueryTableType = "MATERIALIZED_VIEW";
/**
 * Snapshot represents an immutable point in time snapshot of some other
 * table.
 */
export const Snapshot: BigQueryTableType = "SNAPSHOT";
export interface DatasourceForJoinableView {
  Project: string;
  Dataset: string;
  Table: string;
  PseudoColumns: string[];
}
export interface JoinableViewDatasource {
  RefDatasource?: DatasourceForJoinableView;
  PseudoDatasource?: DatasourceForJoinableView;
}
export interface GCPProject {
  id: string;
  name: string;
  group?: GoogleGroup;
}
export interface BigQuery {
  ID: string /* uuid */;
  DatasetID: string /* uuid */;
  projectID: string;
  dataset: string;
  table: string;
  tableType: BigQueryTableType;
  lastModified: string /* RFC3339 */;
  created: string /* RFC3339 */;
  expired?: string /* RFC3339 */;
  description: string;
  piiTags?: string;
  missingSince?: string /* RFC3339 */;
  pseudoColumns: string[];
  schema: (BigqueryColumn | undefined)[];
}
export interface BQTables {
  bqTables: (BigQueryTable | undefined)[];
}
export interface BQDatasets {
  bqDatasets: string[];
}
export interface BQColumns {
  bqColumns: (BigqueryColumn | undefined)[];
}
export interface NewBigQuery {
  projectID: string;
  dataset: string;
  table: string;
  piiTags?: string;
}
export interface BigquerySchema {
  Columns: (BigqueryColumn | undefined)[];
}
export interface BigqueryMetadata {
  schema: BigquerySchema;
  tableType: BigQueryTableType;
  lastModified: string /* RFC3339 */;
  created: string /* RFC3339 */;
  expires: string /* RFC3339 */;
  description: string;
}
export interface BigQueryDataSourceUpdate {
  PiiTags?: string;
  PseudoColumns: string[];
  DatasetID: string /* uuid */;
}
export interface BigqueryColumn {
  name: string;
  type: string;
  mode: string;
  description: string;
}
export interface BigQueryTable {
  description: string;
  lastModified: string /* RFC3339 */;
  name: string;
  type: BigQueryTableType;
}

//////////
// source: cloud_storage.go

export type CloudStorageAPI = any;

//////////
// source: cloudbilling.go

export type CloudBillingAPI = any /* cloudbilling.Operations */;

//////////
// source: cloudlogging.go

export type CloudLoggingAPI = any;
export interface ListLogEntriesOpts {
  ResourceNames: string[];
  Filter: string;
}
export interface HTTPRequest {
  UserAgent: string;
  URL?: any /* url.URL */;
  Method: string;
}
export interface LogEntry {
  HTTPRequest?: HTTPRequest;
  Timestamp: string /* RFC3339 */;
}

//////////
// source: cloudresourcemanager.go

export type CloudResourceManagerAPI = any;
export interface EffectiveTags {
  tags?: (EffectiveTag | undefined)[];
}
export interface EffectiveTag {
  /**
   * NamespacedTagKey: The namespaced name of the TagKey. Can be in the form
   * `{organization_id}/{tag_key_short_name}` or
   * `{project_id}/{tag_key_short_name}` or
   * `{project_number}/{tag_key_short_name}`.
   */
  namespacedTagKey?: string;
  /**
   * NamespacedTagValue: The namespaced name of the TagValue. Can be in the form
   * `{organization_id}/{tag_key_short_name}/{tag_value_short_name}` or
   * `{project_id}/{tag_key_short_name}/{tag_value_short_name}` or
   * `{project_number}/{tag_key_short_name}/{tag_value_short_name}`.
   */
  namespacedTagValue?: string;
  /**
   * TagKey: The name of the TagKey, in the format `tagKeys/{id}`, such as
   * `tagKeys/123`.
   */
  tagKey?: string;
  /**
   * TagKeyParentName: The parent name of the tag key. Must be in the format
   * `organizations/{organization_id}` or `projects/{project_number}`
   */
  tagKeyParentName?: string;
  /**
   * TagValue: Resource name for TagValue in the format `tagValues/456`.
   */
  tagValue?: string;
}
export interface Binding {
  Role: string;
  Members: string[];
}

//////////
// source: compute.go

export type ComputeAPI = any;
export type ComputeService = any;
export interface VirtualMachine {
  Name: string;
  ID: number /* uint64 */;
  Zone: string;
  FullyQualifiedZone: string;
  IPs: string[];
}
export interface FirewallRule {
  Name: string;
  SecureTags: string[];
  Description: string;
}
export interface Label {
  Key: string;
  Value: string;
}

//////////
// source: dataproducts.go

export type DataProductsStorage = any;
export type DataProductsService = any;
export type PiiLevel = string;
export const PiiLevelSensitive: PiiLevel = "sensitive";
export const PiiLevelAnonymised: PiiLevel = "anonymised";
export const PiiLevelNone: PiiLevel = "none";
export type DatasourceType = string;
export interface Dataset {
  id: string /* uuid */;
  dataproductID: string /* uuid */;
  name: string;
  created: string /* RFC3339 */;
  lastModified: string /* RFC3339 */;
  description?: string;
  slug: string;
  repo?: string;
  pii: PiiLevel;
  keywords: string[];
  anonymisationDescription?: string;
  targetUser?: string;
  datasource?: BigQuery;
  metabaseUrl?: string;
  metabaseDeletedAt?: string /* RFC3339 */;
}
export interface DatasetWithAccess {
  id: string /* uuid */;
  dataproductID: string /* uuid */;
  name: string;
  created: string /* RFC3339 */;
  lastModified: string /* RFC3339 */;
  description?: string;
  slug: string;
  repo?: string;
  pii: PiiLevel;
  keywords: string[];
  anonymisationDescription?: string;
  targetUser?: string;
  access: (Access | undefined)[];
  datasource?: BigQuery;
  metabaseUrl?: string;
  metabaseDeletedAt?: string /* RFC3339 */;
}
export interface AccessibleDataset {
  Dataset: Dataset;
  dataproductName: string;
  slug: string;
  dpSlug: string;
  group: string;
  subject?: string;
  accessID?: string /* uuid */;
}
export interface AccessibleDatasets {
  /**
   * owned
   */
  owned: (AccessibleDataset | undefined)[];
  /**
   * granted
   */
  granted: (AccessibleDataset | undefined)[];
  /**
   * service account granted
   */
  serviceAccountGranted: (AccessibleDataset | undefined)[];
}
export interface DatasetMinimal {
  id: string /* uuid */;
  name: string;
  created: string /* RFC3339 */;
  project: string;
  dataset: string;
  table: string;
}
export interface DatasetInDataproduct {
  id: string /* uuid */;
  name: string;
  created: string /* RFC3339 */;
  lastModified: string /* RFC3339 */;
  description?: string;
  slug: string;
  keywords: string[];
  dataSourceLastModified: string /* RFC3339 */;
}
export interface NewDataset {
  dataproductID: string /* uuid */;
  name: string;
  description?: string;
  slug?: string;
  repo?: string;
  pii: PiiLevel;
  keywords: string[];
  bigquery: NewBigQuery;
  anonymisationDescription?: string;
  grantAllUsers?: boolean;
  targetUser?: string;
  Metadata: BigqueryMetadata;
  pseudoColumns: string[];
}
export interface UpdateDatasetDto {
  name: string;
  description?: string;
  slug?: string;
  repo?: string;
  pii: PiiLevel;
  keywords: string[];
  dataproductID?: string /* uuid */;
  anonymisationDescription?: string;
  piiTags?: string;
  targetUser?: string;
  pseudoColumns: string[];
}
export interface DataproductOwner {
  group: string;
  teamkatalogenURL?: string;
  teamContact?: string;
  teamID?: string /* uuid */;
  productAreaID?: string /* uuid */;
}
export interface Dataproduct {
  id: string /* uuid */;
  name: string;
  created: string /* RFC3339 */;
  lastModified: string /* RFC3339 */;
  description?: string;
  slug: string;
  owner?: DataproductOwner;
  keywords: string[];
  teamName?: string;
  productAreaName: string;
}
export interface DataproductMinimal {
  id: string /* uuid */;
  name: string;
  created: string /* RFC3339 */;
  lastModified: string /* RFC3339 */;
  description?: string;
  slug: string;
  owner?: DataproductOwner;
}
export interface DataproductWithDataset extends Dataproduct {
  datasets: (DatasetInDataproduct | undefined)[];
}
/**
 * PseudoDataset contains information about a pseudo dataset
 */
export interface PseudoDataset {
  /**
   * name is the name of the dataset
   */
  name: string;
  /**
   * datasetID is the id of the dataset
   */
  datasetID: string /* uuid */;
  /**
   * datasourceID is the id of the bigquery datasource
   */
  datasourceID: string /* uuid */;
}
/**
 * NewDataproduct contains metadata for creating a new dataproduct
 */
export interface NewDataproduct {
  /**
   * name of dataproduct
   */
  name: string;
  /**
   * description of the dataproduct
   */
  description?: string;
  /**
   * owner group email for the dataproduct.
   */
  group: string;
  /**
   * owner Teamkatalogen URL for the dataproduct.
   */
  teamkatalogenURL?: string;
  /**
   * The contact information of the team who owns the dataproduct, which can be slack channel, slack account, email, and so on.
   */
  teamContact?: string;
  /**
   * Id of the team's product area.
   */
  productAreaID?: string /* uuid */;
  /**
   * Id of the team.
   */
  teamID?: string /* uuid */;
  Slug?: string;
}
export interface UpdateDataproductDto {
  name: string;
  description?: string;
  slug?: string;
  pii: PiiLevel;
  teamkatalogenURL?: string;
  teamContact?: string;
  productAreaID?: string /* uuid */;
  teamID?: string /* uuid */;
}

//////////
// source: datavarehus.go

export type DatavarehusAPI = any;
export interface TNSName {
  TnsName: string;
  Name: string;
  Description: string;
  Host: string;
  Port: string;
  ServiceName: string;
}

//////////
// source: errors.go

export const CodeGCPArtifactRegistry: string = "gcp_artifact_registry";
export const CodeGCPBigQuery: string = "gcp_bigquery";
export const CodeGCPCloudLogging: string = "gcp_cloud_logging";
export const CodeGCPCloudResourceManager: string = "gcp_cloud_resource_manager";
export const CodeGCPComputeEngine: string = "gcp_compute_engine";
export const CodeGCPSecureWebProxy: string = "gcp_secure_web_proxy";
export const CodeGCPServiceAccount: string = "gcp_service_account";
export const CodeGCPStorage: string = "gcp_storage";
export const CodeGCPWorkstation: string = "gcp_workstation";
export const CodeGCPIAMCredentials: string = "gcp_iamcredentials";
export const CodeMetabase: string = "metabase";
export const CodeNaisConsole: string = "nais_console";
export const CodePolly: string = "polly";
export const CodeTeamKatalogen: string = "team_katalogen";
export const CodeSlack: string = "slack";
export const CodeDatavarehus: string = "datavarehus";
export const CodeTransactionalQueue: string = "transactional_queue";
export const CodeDatabase: string = "database";
export const CodeInternalDecoding: string = "internal_decoding";
export const CodeInternalEncoding: string = "internal_encoding";
export const CodeExternalEncoding: string = "external_encoding";
export const CodeCrypto: string = "crypto";
export const CodeOpeningDatasetWithPiiTags: string = "opening_dataset_with_pii_tags";
export const CodeOpeningClosedDatabase: string = "opening_closed_database";
export const CodeUnexpectedSubjectFormat: string = "subject_format";
export const CodeExpiresInPast: string = "expires_in_past";
export const CodeWrongOwner: string = "wrong_owner";
export const CodeWrongTeam: string = "wrong_team";
export const CodeWaitingForDatabase: string = "waiting_for_database";
export const CodeDatasetNotSynced: string = "dataset_not_synced";
export const CodeTeamMissing: string = "team_missing";
export const CodeUserMissing: string = "user_missing";
export const CodeUnknownHostInOnPremAllowList: string = "unknown_host_in_on_prem_allow_list";
export const CodeNotLoggedIn: string = "not_logged_in";
export const CodeNotNotAllowed: string = "not_allowed";
export const ParamDataset: string = "dataset";
export const ParamAccessRequest: string = "access_request";
export const ParamUser: string = "user";
export const ParamOwner: string = "owner";
export const ParamPiiTags: string = "pii_tags";
export const ParamDataProduct: string = "data_product";
export const ParamSchema: string = "schema";
export const ParamInsightProduct: string = "insight_product";
export const ParamDatasource: string = "datasource";
export const ParamGroupEmail: string = "group_email";
export const ParamPolly: string = "polly";
export const ParamProductArea: string = "product_area";
export const ParamStory: string = "story";
export const ParamJob: string = "job";
export const ParamTable: string = "table";
export const ParamPolicy: string = "policy";
export const ParamPolicyRule: string = "policy_rule";
export const ParamURLList: string = "url_list";
export const ParamServiceAccount: string = "service_account";
export const ParamObject: string = "object";
export const ParamWorkstation: string = "workstation";
export const ParamExternalRequest: string = "external_request";
export const ParamExternalResponse: string = "external_response";
export const ParamTeam: string = "team";
export const ParamChannel: string = "channel";
export const ParamTableType: string = "table_type";
export const ParamToken: string = "token";
export const KindOther: string = "other_error";
export const KindInvalid: string = "invalid_operation";
export const KindIO: string = "io_error";
export const KindExist: string = "item_exists";
export const KindNotExist: string = "item_not_exist";
export const KindBrokenLink: string = "link_target_not_exist";
export const KindPrivate: string = "information_withheld";
export const KindInternal: string = "internal_error";
export const KindDatabase: string = "database_error";
export const KindValidation: string = "input_validation_error";
export const KindUnanticipated: string = "unanticipated_error";
export const KindInvalidRequest: string = "invalid_request_error";
export const KindUnauthenticated: string = "unauthenticated_request";
export const KindUnauthorized: string = "unauthorized_request";
export const KindUnsupportedMediaType: string = "unsupported_media_type";
export const KindUnknown: string = "unknown_error_kind";

//////////
// source: iamcredentials.go

export type IAMCredentialsAPI = any;
export interface SignedJWT {
  SignedJWT: string;
  KeyID: string;
}
export interface DVHClaims {
  Ident: string;
  IP: string;
  Databases: string[];
  Reference: string;
  PodName: string;
  KnastContainerImage: string;
  SessionDurationSec: number /* int */;
}

//////////
// source: insight_products.go

export type InsightProductStorage = any;
export type InsightProductService = any;
/**
 * InsightProduct contains the metadata of insight product.
 */
export interface InsightProduct {
  /**
   * id of the insight product.
   */
  id: string /* uuid */;
  /**
   * name of the insight product.
   */
  name: string;
  /**
   * creator of the insight product.
   */
  creator: string;
  /**
   * description of the insight product.
   */
  description: string;
  /**
   * type of the insight product.
   */
  type: string;
  /**
   * link to the insight product.
   */
  link: string;
  /**
   * keywords for the insight product used as tags.
   */
  keywords: string[];
  /**
   * group is the owner group of the insight product
   */
  group: string;
  /**
   * teamkatalogenURL of the creator
   */
  teamkatalogenURL?: string;
  /**
   * Id of the creator's team.
   */
  teamID?: string /* uuid */;
  /**
   * created is the timestamp for when the insight product was created
   */
  created: string /* RFC3339 */;
  /**
   * lastModified is the timestamp for when the insight product was last modified
   */
  lastModified?: string /* RFC3339 */;
  teamName?: string;
  productAreaName: string;
}
export interface UpdateInsightProductDto {
  name: string;
  description: string;
  type: string;
  link: string;
  keywords: string[];
  teamkatalogenURL?: string;
  productAreaID?: string /* uuid */;
  teamID?: string /* uuid */;
  group: string;
}
/**
 * NewInsightProduct contains the metadata and content of insight products.
 */
export interface NewInsightProduct {
  name: string;
  description?: string;
  type: string;
  link: string;
  keywords: string[];
  /**
   * Group is the owner group of the insight product
   */
  group: string;
  /**
   * TeamkatalogenURL of the creator
   */
  teamkatalogenURL?: string;
  /**
   * Id of the creator's product area.
   */
  productAreaID?: string /* uuid */;
  /**
   * Id of the creator's team.
   */
  teamID?: string /* uuid */;
}

//////////
// source: jobs.go

export interface JobHeader {
  id: number /* int64 */;
  startTime: string /* RFC3339 */;
  endTime?: string /* RFC3339 */;
  state: JobState;
  duplicate: boolean;
  errors: string[];
  kind: string;
}
export type JobState = string;
export const JobStateCompleted: JobState = "COMPLETED";
export const JobStateRunning: JobState = "RUNNING";
export const JobStateFailed: JobState = "FAILED";
export const JobStatePending: JobState = "PENDING";

//////////
// source: joinable_views.go

export type JoinableViewsStorage = any;
export type JoinableViewsService = any;
export interface JoinableViewToBeDeletedWithRefDatasource {
  JoinableViewID: string /* uuid */;
  JoinableViewName: string;
  BqProjectID: string;
  BqDatasetID: string;
  BqTableID: string;
}
export interface JoinableViewWithReference {
  Owner: string;
  JoinableViewID: string /* uuid */;
  JoinableViewDataset: string;
  PseudoViewID: string /* uuid */;
  PseudoProjectID: string;
  PseudoDataset: string;
  PseudoTable: string;
  Expires: any /* sql.NullTime */;
}
export interface JoinableViewWithDataset {
  BqProject: string;
  BqDataset: string;
  BqTable: string;
  Deleted?: string /* RFC3339 */;
  DatasetID: null | string /* uuid */;
  JoinableViewID: string /* uuid */;
  Group: string;
  JoinableViewName: string;
  JoinableViewCreated: string /* RFC3339 */;
  JoinableViewExpires?: string /* RFC3339 */;
}
export interface JoinableViewForReferenceAndUser {
  ID: string /* uuid */;
  Dataset: string;
}
export interface JoinableViewForOwner {
  ID: string /* uuid */;
  Name: string;
  Owner: string;
  Created: string /* RFC3339 */;
  Expires?: string /* RFC3339 */;
  ProjectID: string;
  DatasetID: string;
  TableID: string;
}
/**
 * NewJoinableViews contains metadata for creating joinable views
 */
export interface NewJoinableViews {
  /**
   * Name is the name of the joinable views which will be used as the name of the dataset in bigquery, which contains all the joinable views
   */
  name: string;
  expires?: string /* RFC3339 */;
  /**
   * DatasetIDs is the IDs of the datasets which are made joinable.
   */
  datasetIDs: string /* uuid */[];
}
export interface JoinableView {
  /**
   * id is the id of the joinable view set
   */
  id: string /* uuid */;
  name: string;
  created: string /* RFC3339 */;
  expires?: string /* RFC3339 */;
}
export interface PseudoDatasource {
  bigqueryUrl: string;
  accessible: boolean;
  deleted: boolean;
}
export interface JoinableViewWithDatasource extends JoinableView {
  pseudoDatasources: PseudoDatasource[];
}

//////////
// source: keywords.go

export type KeywordsStorage = any;
export type KeywordsService = any;
export interface KeywordsList {
  keywordItems: KeywordItem[];
}
export interface KeywordItem {
  keyword: string;
  count: number /* int */;
}
export interface UpdateKeywordsDto {
  obsoleteKeywords: string[];
  replacedKeywords: string[];
  newText: string[];
}

//////////
// source: kms.go

export type KMSAPI = any;
export interface KeyIdentifier {
  Project: string;
  Location: string;
  Keyring: string;
  KeyName: string;
}

//////////
// source: metabase.go

export const MetabaseRestrictedCollectionTag = "🔐";
export const MetabaseAllUsersGroupID = 1;
export type MetabaseStorage = any;
export type MetabaseAPI = any;
export type MetabaseQueue = any;
export type MetabaseService = any;
export interface MetabaseBigQueryDatasetStatus extends Partial<MetabaseMetadata> {
  isRunning: boolean;
  isCompleted: boolean;
  isRestricted: boolean;
  hasFailed: boolean;
  jobs: JobHeader[];
}
export interface MetabaseOpenBigqueryDatabaseWorkflowStatus {
  preflightCheckJob?: MetabasePreflightCheckOpenBigqueryDatabaseJob;
  databaseJob?: MetabaseCreateOpenBigqueryDatabaseJob;
  verifyJob?: MetabaseVerifyOpenBigqueryDatabaseJob;
  finalizeJob?: MetabaseFinalizeOpenBigqueryDatabaseJob;
}
export interface MetabaseRestrictedBigqueryDatabaseWorkflowStatus {
  preflightCheckJob?: MetabasePreflightCheckRestrictedBigqueryDatabaseJob;
  permissionGroupJob?: MetabaseCreatePermissionGroupJob;
  collectionJob?: MetabaseCreateCollectionJob;
  serviceAccountJob?: MetabaseEnsureServiceAccountJob;
  serviceAccountKeyJob?: MetabaseCreateServiceAccountKeyJob;
  projectIAMJob?: MetabaseAddProjectIAMPolicyBindingJob;
  databaseJob?: MetabaseBigqueryCreateDatabaseJob;
  verifyJob?: MetabaseBigqueryVerifyDatabaseJob;
  finalizeJob?: MetabaseBigqueryFinalizeDatabaseJob;
}
export interface MetabasePreflightCheckOpenBigqueryDatabaseJob extends JobHeader {
  datasetID: string /* uuid */;
}
export interface MetabaseCreateOpenBigqueryDatabaseJob extends JobHeader {
  datasetID: string /* uuid */;
}
export interface MetabaseVerifyOpenBigqueryDatabaseJob extends JobHeader {
  datasetID: string /* uuid */;
}
export interface MetabaseFinalizeOpenBigqueryDatabaseJob extends JobHeader {
  datasetID: string /* uuid */;
}
export interface MetabasePreflightCheckRestrictedBigqueryDatabaseJob extends JobHeader {
  datasetID: string /* uuid */;
}
export interface MetabaseCreatePermissionGroupJob extends JobHeader {
  datasetID: string /* uuid */;
  permissionGroupName: string;
}
export interface MetabaseCreateCollectionJob extends JobHeader {
  datasetID: string /* uuid */;
  collectionName: string;
}
export interface MetabaseEnsureServiceAccountJob extends JobHeader {
  datasetID: string /* uuid */;
  accountID: string;
  projectID: string;
  displayName: string;
  description: string;
}
export interface MetabaseCreateServiceAccountKeyJob extends JobHeader {
  datasetID: string /* uuid */;
}
export interface MetabaseAddProjectIAMPolicyBindingJob extends JobHeader {
  datasetID: string /* uuid */;
  projectID: string;
  role: string;
  member: string;
}
export interface MetabaseBigqueryCreateDatabaseJob extends JobHeader {
  datasetID: string /* uuid */;
}
export interface MetabaseBigqueryVerifyDatabaseJob extends JobHeader {
  datasetID: string /* uuid */;
}
export interface MetabaseBigqueryFinalizeDatabaseJob extends JobHeader {
  datasetID: string /* uuid */;
}
export interface MetabaseBigqueryDatabaseDeleteJob extends JobHeader {
  datasetID: string /* uuid */;
}
export interface MetabaseRestrictedBigqueryDatabaseWorkflowOpts {
  DatasetID: string /* uuid */;
  PermissionGroupName: string;
  CollectionName: string;
  ProjectID: string;
  AccountID: string;
  DisplayName: string;
  Description: string;
  Role: string;
  Member: string;
}
export interface MetabaseField {
  id: number /* int */;
  database_type: string;
  semantic_type: string;
}
export interface MetabaseTable {
  name: string;
  id: number /* int */;
  fields: MetabaseField[];
}
export interface MetabasePermissionGroup {
  id: number /* int */;
  name: string;
  members: MetabasePermissionGroupMember[];
}
export interface MetabasePermissionGroupMember {
  membership_id: number /* int */;
  email: string;
}
export interface MetabaseUser {
  email: string;
  id: number /* int */;
  last_login?: string /* RFC3339 */;
  is_active: boolean;
}
export interface MetabaseDatabase {
  ID: number /* int */;
  Name: string;
  DatasetID: string;
  ProjectID: string;
  NadaID: string;
  SAEmail: string;
}
export interface MetabaseMetadata {
  datasetID: string /* uuid */;
  databaseID?: number /* int */;
  permissionGroupID?: number /* int */;
  collectionID?: number /* int */;
  saEmail: string;
  deletedAt?: string /* RFC3339 */;
  syncCompleted?: string /* RFC3339 */;
}
/**
 * MetabaseCollection represents a subset of the metadata returned
 * for a Metabase collection
 */
export interface MetabaseCollection {
  ID: number /* int */;
  Name: string;
  Description: string;
}
export interface PermissionGraphGroups {
  revision: number /* int */;
  groups: { [key: string]: { [key: string]: PermissionGroup}};
}
export interface PermissionGroup {
  'view-data'?: string;
  'create-queries'?: string;
  details?: string;
  download?: DownloadPermission;
  'data-model'?: DataModelPermission;
}
export interface DataModelPermission {
  schemas?: string;
}
export interface DownloadPermission {
  schemas?: string;
}

//////////
// source: nais_console.go

export type NaisConsoleStorage = any;
export type NaisConsoleAPI = any;
export type NaisConsoleService = any;
export interface NaisTeamMapping {
  Slug: string;
  GroupEmail: string;
  ProjectID: string;
}

//////////
// source: onprem_mapping.go

export type OnpremMappingService = any;
export interface Host {
  Name: string;
  Description: string;
  Host: string;
}
export interface ClassifiedHosts {
  hosts: { [key: OnpremHostType]: (Host | undefined)[]};
}
export type OnpremHostType = string;
export const OnpremHostTypeOracle: OnpremHostType = "oracle";
export const OnpremHostTypePostgres: OnpremHostType = "postgres";
export const OnpremHostTypeInformatica: OnpremHostType = "informatica";
export const OnpremHostTypeSFTP: OnpremHostType = "sftp";
export const OnpremHostTypeHTTP: OnpremHostType = "http";
export const OnpremHostTypeTDV: OnpremHostType = "tdv";
export const OnpremHostTypeSMTP: OnpremHostType = "smtp";
export const OnpremHostTypeTNS: OnpremHostType = "tns";
export const OnpremHostTypeCloudSQL: OnpremHostType = "cloudsql";

//////////
// source: polly.go

export type PollyStorage = any;
export type PollyAPI = any;
export type PollyService = any;
export interface Polly extends QueryPolly {
  id: string /* uuid */;
}
export interface PollyInput extends QueryPolly {
  id?: string /* uuid */;
}
export interface QueryPolly {
  externalID: string;
  name: string;
  url: string;
}

//////////
// source: productareas.go

export type ProductAreaStorage = any;
export type ProductAreaService = any;
export interface UpsertProductAreaRequest {
  ID: string /* uuid */;
  Name: string;
}
/**
 * FIXCME: does this belong here?
 */
export interface UpsertTeamRequest {
  ID: string /* uuid */;
  ProductAreaID: string /* uuid */;
  Name: string;
}
export interface PATeam extends Partial<TeamkatalogenTeam> {
  dataproductsNumber: number /* int */;
  storiesNumber: number /* int */;
  insightProductsNumber: number /* int */;
}
/**
 * FIXME: we need to simplify these structs, there is too much duplication
 */
export interface ProductAreasDto {
  productAreas: (ProductArea | undefined)[];
}
export interface ProductAreaBase extends Partial<TeamkatalogenProductArea> {
  dashboardURL: string;
}
export interface ProductArea extends Partial<ProductAreaBase> {
  teams: (PATeam | undefined)[];
}
export interface PATeamWithAssets extends Partial<TeamkatalogenTeam> {
  dataproducts: (Dataproduct | undefined)[];
  stories: (Story | undefined)[];
  insightProducts: (InsightProduct | undefined)[];
  dashboardURL: string;
}
export interface Dashboard {
  ID: string /* uuid */;
  Url: string;
}
export interface ProductAreaWithAssets extends Partial<ProductAreaBase> {
  teamsWithAssets: (PATeamWithAssets | undefined)[];
}

//////////
// source: prometheus.go

/**
 * Middleware is a handler that exposes prometheus metrics for the number of requests,
 * the latency and the response size, partitioned by status code, method and HTTP path.
 */
export interface Middleware {
}

//////////
// source: search.go

export type SearchStorage = any;
export type SearchService = any;
export type ResultItem = any;
export interface SearchResult {
  results: (SearchResultRow | undefined)[];
}
export interface SearchResultRaw {
  ElementID: string /* uuid */;
  ElementType: string;
  Rank: number /* float32 */;
  Excerpt: string;
}
export interface SearchResultRow {
  excerpt: string;
  result: ResultItem;
  rank: number /* float64 */;
}
export interface SearchOptions {
  /**
   * Freetext search
   */
  text: string;
  /**
   * Filter on keyword
   */
  keywords: string[];
  /**
   * Filter on group
   */
  groups: string[];
  /**
   * Filter on team_id
   */
  teamIDs: string /* uuid */[];
  /**
   * Filter on types
   */
  types: string[];
  limit?: number /* int */;
  offset?: number /* int */;
}

//////////
// source: secure_web_proxy.go

export const FirewallAllowRulePriorityMin = 1000;
export const FirewallAllowRulePriorityMax = 200_000_000;
export const FirewallDenyRulePriorityMin = 210_000_000;
export const FirewallDenyRulePriorityMax = 410_000_000;
export const GlobalURLAllowListName = "global-allow";
export type SecureWebProxyAPI = any;
export interface EnsureProxyRuleWithURLList {
  /**
   * Project is the gcp project id
   */
  Project: string;
  /**
   * Location is the gcp region
   */
  Location: string;
  /**
   * Slug is the name of the url list
   */
  Slug: string;
}
export interface URLListIdentifier {
  /**
   * Project is the gcp project id
   */
  Project: string;
  /**
   * Location is the gcp region
   */
  Location: string;
  /**
   * Slug is the name of the url list
   */
  Slug: string;
}
export interface PolicyRuleIdentifier {
  /**
   * Project is the gcp project id
   */
  Project: string;
  /**
   * Location is the gcp region
   */
  Location: string;
  /**
   * Policy is the name of the policy the rule is part of
   */
  Policy: string;
  /**
   * Slug is the name of the policy rule
   */
  Slug: string;
}
export interface PolicyIdentifier {
  /**
   * Project is the gcp project id
   */
  Project: string;
  /**
   * Location is the gcp region
   */
  Location: string;
  /**
   * Policy is the name of the policy the rule is part of
   */
  Policy: string;
}
export interface GatewaySecurityPolicyRule {
  /**
   * ApplicationMatcher: Optional. CEL expression for matching on L7/application
   * level criteria.
   */
  ApplicationMatcher: string;
  /**
   * BasicProfile: Required. Profile which tells what the primitive action should
   * be.
   * Possible values:
   *   "BASIC_PROFILE_UNSPECIFIED" - If there is not a mentioned action for the
   * target.
   *   "ALLOW" - Allow the matched traffic.
   *   "DENY" - Deny the matched traffic.
   */
  BasicProfile: string;
  /**
   * CreateTime: Output only. Time when the rule was created.
   */
  CreateTime: string;
  /**
   * Description: Optional. Free-text description of the resource.
   */
  Description: string;
  /**
   * Enabled: Required. Whether the rule is enforced.
   */
  Enabled: boolean;
  /**
   * Name: Required. Immutable. Name of the resource. ame is the full resource
   * name so
   * projects/{project}/locations/{location}/gatewaySecurityPolicies/{gateway_secu
   * rity_policy}/rules/{rule} rule should match the pattern: (^a-z
   * ([a-z0-9-]{0,61}[a-z0-9])?$).
   */
  Name: string;
  /**
   * Priority: Required. Priority of the rule. Lower number corresponds to higher
   * precedence.
   */
  Priority: number /* int64 */;
  /**
   * SessionMatcher: Required. CEL expression for matching on session criteria.
   */
  SessionMatcher: string;
  /**
   * TlsInspectionEnabled: Optional. Flag to enable TLS inspection of traffic
   * matching on , can only be true if the parent GatewaySecurityPolicy
   * references a TLSInspectionConfig.
   */
  TlsInspectionEnabled: boolean;
  /**
   * UpdateTime: Output only. Time when the rule was updated.
   */
  UpdateTime: string;
}
export interface PolicyRuleEnsureOpts {
  ID?: PolicyRuleIdentifier;
  Rule?: GatewaySecurityPolicyRule;
}
export interface PolicyRuleEnsureNextAvailablePortOpts {
  ID?: PolicyIdentifier;
  /**
   * PriorityMinRange is the minimum priority range to use
   */
  PriorityMinRange: number /* int */;
  /**
   * PriorityMaxRange is the maximum priority range to use
   */
  PriorityMaxRange: number /* int */;
  /**
   * ApplicationMatcher: Optional. CEL expression for matching on L7/application
   * level criteria.
   */
  ApplicationMatcher: string;
  /**
   * BasicProfile: Required. Profile which tells what the primitive action should
   * be.
   * Possible values:
   *   "BASIC_PROFILE_UNSPECIFIED" - If there is not a mentioned action for the
   * target.
   *   "ALLOW" - Allow the matched traffic.
   *   "DENY" - Deny the matched traffic.
   */
  BasicProfile: string;
  /**
   * Description: Optional. Free-text description of the resource.
   */
  Description: string;
  /**
   * Enabled: Required. Whether the rule is enforced.
   */
  Enabled: boolean;
  /**
   * Name: Required. Immutable. Name of the resource. ame is the full resource
   * name so
   * projects/{project}/locations/{location}/gatewaySecurityPolicies/{gateway_secu
   * rity_policy}/rules/{rule} rule should match the pattern: (^a-z
   * ([a-z0-9-]{0,61}[a-z0-9])?$).
   */
  Name: string;
  /**
   * SessionMatcher: Required. CEL expression for matching on session criteria.
   */
  SessionMatcher: string;
  /**
   * TlsInspectionEnabled: Optional. Flag to enable TLS inspection of traffic
   * matching on , can only be true if the parent GatewaySecurityPolicy
   * references a TLSInspectionConfig.
   */
  TlsInspectionEnabled: boolean;
}
export interface PolicyRuleCreateOpts {
  ID?: PolicyRuleIdentifier;
  Rule?: GatewaySecurityPolicyRule;
}
export interface PolicyRuleUpdateOpts {
  ID?: PolicyRuleIdentifier;
  Rule?: GatewaySecurityPolicyRule;
}
export interface URLListEnsureOpts {
  ID?: URLListIdentifier;
  Description: string;
  URLS: string[];
}
export interface URLListCreateOpts {
  ID?: URLListIdentifier;
  Description: string;
  URLS: string[];
}
export interface URLListUpdateOpts {
  ID?: URLListIdentifier;
  Description: string;
  URLS: string[];
}

//////////
// source: serviceaccount.go

export const ServiceAccountUserRole = "roles/iam.serviceAccountUser";
export type ServiceAccountAPI = any;
export interface ServiceAccountRequest {
  ProjectID: string;
  AccountID: string;
  DisplayName: string;
  Description: string;
}
export interface ServiceAccountMeta {
  Description: string;
  DisplayName: string;
  Email: string;
  Name: string;
  ProjectId: string;
  UniqueId: string;
}
export interface ServiceAccount {
  ServiceAccountMeta?: ServiceAccountMeta;
  Keys: (ServiceAccountKey | undefined)[];
}
export interface ServiceAccountWithPrivateKey {
  ServiceAccountMeta?: ServiceAccountMeta;
  Key?: ServiceAccountKeyWithPrivateKeyData;
}
export interface ServiceAccountKey {
  Name: string;
  KeyAlgorithm: string;
  KeyOrigin: string;
  KeyType: string;
}
export interface ServiceAccountKeyWithPrivateKeyData {
  ServiceAccountKey?: ServiceAccountKey;
  PrivateKeyData: string;
}

//////////
// source: slack.go

export interface IsValidSlackChannelResult {
  isValidSlackChannel: boolean;
}
export type SlackAPI = any;
export type SlackService = any;

//////////
// source: stories.go

export type StoryStorage = any;
export type StoryService = any;
export interface UploadFile {
  /**
   * path of the file uploaded
   */
  path: string;
  /**
   * file data
   */
  ReadCloser: any /* io.ReadCloser */;
}
/**
 * Story contains the metadata and content of data stories.
 */
export interface Story {
  /**
   * id of the data story.
   */
  id: string /* uuid */;
  /**
   * name of the data story.
   */
  name: string;
  /**
   * creator of the data story.
   */
  creator: string;
  /**
   * description of the data story.
   */
  description: string;
  /**
   * keywords for the story used as tags.
   */
  keywords: string[];
  /**
   * teamkatalogenURL of the creator.
   */
  teamkatalogenURL?: string;
  /**
   * Id of the creator's team.
   */
  teamID?: string /* uuid */;
  /**
   * created is the timestamp for when the data story was created.
   */
  created: string /* RFC3339 */;
  /**
   * lastModified is the timestamp for when the dataproduct was last modified.
   */
  lastModified?: string /* RFC3339 */;
  /**
   * group is the owner group of the data story.
   */
  group: string;
  teamName?: string;
  productAreaName: string;
}
/**
 * NewStory contains the metadata and content of data stories.
 */
export interface NewStory {
  /**
   * id of data story.
   */
  id?: string /* uuid */;
  /**
   * name of the data story.
   */
  name: string;
  /**
   * description of the data story.
   */
  description?: string;
  /**
   * keywords for the story used as tags.
   */
  keywords: string[];
  /**
   * teamkatalogenURL of the creator.
   */
  teamkatalogenURL?: string;
  /**
   * Id of the creator's product area.
   */
  productAreaID?: string /* uuid */;
  /**
   * Id of the creator's team.
   */
  teamID?: string /* uuid */;
  /**
   * group is the owner group of the data story.
   */
  group: string;
}
export interface UpdateStoryDto {
  name: string;
  description: string;
  keywords: string[];
  teamkatalogenURL?: string;
  productAreaID?: string /* uuid */;
  teamID?: string /* uuid */;
  group: string;
}
export interface Object {
  Name: string;
  Bucket: string;
  Attrs: Attributes;
}
export interface Attributes {
  ContentType: string;
  ContentEncoding: string;
  Size: number /* int64 */;
  SizeStr: string;
}
export interface ObjectWithData {
  Object?: Object;
  Data: string;
}

//////////
// source: teamkatalogen.go

export type TeamKatalogenAPI = any;
export type TeamKatalogenService = any;
export interface TeamkatalogenResult {
  teamID: string;
  url: string;
  name: string;
  description: string;
  productAreaID: string;
}
export interface TeamkatalogenProductArea {
  /**
   * id is the id of the product area.
   */
  id: string /* uuid */;
  /**
   * name is the name of the product area.
   */
  name: string;
  /**
   * areaType is the type of the product area.
   */
  areaType: string;
}
export interface TeamkatalogenTeam {
  /**
   * id is the team external id in teamkatalogen.
   */
  id: string /* uuid */;
  /**
   * name is the name of the team.
   */
  name: string;
  /**
   * productAreaID is the id of the product area.
   */
  productAreaID: string /* uuid */;
}

//////////
// source: tokens.go

export type TokenStorage = any;
export type TokenService = any;
export interface NadaToken {
  team: string;
  token: string /* uuid */;
}

//////////
// source: user.go

export type UserService = any;
export interface User {
  name: string;
  email: string;
  NAVident: string;
  IsKnastUser: boolean;
  AzureGroups: AzureGroups;
  GoogleGroups: GoogleGroups;
  AllGoogleGroups: GoogleGroups;
  expiry: string /* RFC3339 */;
}
export interface AzureGroup {
  name: string;
  email: string;
  objectId: string;
}
export type AzureGroups = AzureGroup[];
export interface GoogleGroup {
  name: string;
  email: string;
}
export type GoogleGroups = GoogleGroup[];
export interface UserInfo {
  /**
   * name of user
   */
  name: string;
  /**
   * email of user.
   */
  email: string;
  /**
   * ident of user
   */
  ident: string;
  /**
   * IsKnastUser is true if the user is eligible to provision a Knast machine.
   */
  isKnastUser: boolean;
  /**
   * googleGroups is the google groups the user is member of.
   */
  googleGroups: GoogleGroups;
  /**
   * allGoogleGroups is the all the known google groups of the user domains.
   */
  allGoogleGroups: GoogleGroups;
  /**
   * azureGroups is the azure groups the user is member of.
   */
  azureGroups: AzureGroups;
  /**
   * gcpProjects is GCP projects the user is a member of.
   */
  gcpProjects: GCPProject[];
  /**
   * loginExpiration is when the token expires.
   */
  loginExpiration: string /* RFC3339 */;
  /**
   * dataproducts is a list of dataproducts with one of the users groups as owner.
   */
  dataproducts: Dataproduct[];
  /**
   * accessable is a list of datasets which the user has either owns or has explicit access to.
   */
  accessable: AccessibleDatasets;
  /**
   * stories is the stories owned by the user's group
   */
  stories: (Story | undefined)[];
  /**
   * insight products is the insight products owned by the user's group
   */
  insightProducts: InsightProduct[];
  /**
   * accessRequests is a list of access requests where either the user or one of the users groups is owner.
   */
  accessRequests: AccessRequest[];
  /**
   * accessRequestsAsGranter is a list of access requests where one of the users groups is obliged to handle.
   */
  accessRequestsAsGranter: AccessRequestForGranter[];
}
export type NadaTokens = NadaToken[];

//////////
// source: workstations.go

export const LabelApp = "app";
export const LabelCreatedBy = "created-by";
export const LabelSubjectIdent = "subject-ident";
export const DefaultCreatedBy = "datamarkedsplassen";
export const DefaultAppKnast = "knast";
/**
 * Strings come from https://cloud.google.com/workstations/docs/available-machine-types
 */
export const MachineTypeN2DStandard2 = "n2d-standard-2";
export const MachineTypeN2DStandard4 = "n2d-standard-4";
export const MachineTypeN2DStandard8 = "n2d-standard-8";
export const MachineTypeN2DStandard16 = "n2d-standard-16";
export const MachineTypeN2DStandard32 = "n2d-standard-32";
export const MachineTypeN2DHighMem2 = "n2d-highmem-2";
export const MachineTypeN2DHighMem4 = "n2d-highmem-4";
export const MachineTypeN2DHighMem8 = "n2d-highmem-8";
export const MachineTypeN2DHighMem16 = "n2d-highmem-16";
export const MachineTypeN2DHighMem32 = "n2d-highmem-32";
export const ContainerImageVSCode = "europe-north1-docker.pkg.dev/cloud-workstations-images/predefined/code-oss:latest";
export const ContainerImageIntellijUltimate = "europe-north1-docker.pkg.dev/cloud-workstations-images/predefined/intellij-ultimate:latest";
export const ContainerImagePosit = "europe-north1-docker.pkg.dev/posit-images/cloud-workstations/workbench:latest";
export const WorkstationDiffDisableGlobalURLAllowList = "disable_global_url_allow_list";
export const WorkstationDiffContainerImage = "container_image";
export const WorkstationDiffMachineType = "machine_type";
export const WorkstationDiffURLAllowList = "url_allow_list";
export const WorkstationDiffOnPremAllowList = "on_prem_allow_list";
export const WorkstationUserRole = "roles/workstations.user";
export const WorkstationImagesTag = "latest";
export const WorkstationDisableGlobalURLAllowListAnnotation = "disable-global-url-allow-list";
export const WorkstationOnpremAllowlistAnnotation = "onprem-allowlist";
/**
 * WorkstationConfigIDLabel is a label applied to the running workstation by GCP
 */
export const WorkstationConfigIDLabel = "workstation_config_id";
export const DefaultWorkstationProxyURL = "http://proxy.knada.local:443";
export const DefaultWorkstationNoProxyList = ".adeo.no,.preprod.local,.test.local,.intern.nav.no,.intern.dev.nav.no,.nais.adeo.no,localhost,metadata.google.internal,169.254.169.254";
export const SecureWebProxyCertFile = "/usr/local/share/ca-certificates/swp.crt";
/**
 * WorkstationEffectiveTagGCPKeyParentName is the key for the parent name in the effective tag set by Google themselves
 * we use this to filter out the tags that are not created by us
 */
export const WorkstationEffectiveTagGCPKeyParentName = "organizations/433637338589";
export const DefaultWorkstationSessionDurationInSec = 43200;
export type WorkstationsService = any;
export type WorkstationsAPI = any;
export type WorkstationsQueue = any;
export type WorkstationsStorage = any;
export type WorkstationActionType = string;
export const WorkstationActionTypeStart = "START";
export const WorkstationActionTypeStop = "STOP";
export interface WorkstationOnpremAllowList {
  hosts: string[];
}
export interface WorkstationZonalTagBindingsJobOpts {
  ident: string;
}
export interface WorkstationZonalTagBindingsJobs {
  jobs: (WorkstationZonalTagBindingsJob | undefined)[];
}
export interface WorkstationConnectJob extends JobHeader {
  ident: string;
  host: string;
}
export interface WorkstationDisconnectJob extends JobHeader {
  ident: string;
  hosts: string[];
}
export interface WorkstationNotifyJob extends JobHeader {
  ident: string;
  requestID: string;
  hosts: string[];
}
export interface WorkstationConnectivityWorkflow {
  connect: (WorkstationConnectJob | undefined)[];
  disconnect?: WorkstationDisconnectJob;
  notify?: WorkstationNotifyJob;
}
export interface WorkstationZonalTagBindingsJob extends JobHeader {
  ident: string;
  requestID: string;
  hosts: string[];
}
export interface WorkstationStartJobs {
  jobs: (WorkstationStartJob | undefined)[];
}
export interface WorkstationStartJob extends JobHeader {
  ident: string;
}
export interface WorkstationJobs {
  jobs: (WorkstationJob | undefined)[];
}
export interface WorkstationJob extends JobHeader {
  name: string;
  email: string;
  ident: string;
  machineType: string;
  containerImage: string;
  diff: { [key: string]: Diff | undefined};
}
export interface Diff {
  added: string[];
  removed: string[];
}
export interface WorkstationJobOpts {
  User?: User;
  Input?: WorkstationInput;
}
export interface WorkstationMachineType {
  machineType: string;
  vCPU: number /* int */;
  memoryGB: number /* int */;
  hourlyCost: number /* float64 */;
}
export interface WorkstationContainer {
  image: string;
  description: string;
  labels: { [key: string]: string};
  documentation: string;
}
export interface WorkstationLogs {
  proxyDeniedHostPaths: (LogEntry | undefined)[];
}
export interface WorkstationOptions {
  /**
   * Container images that are allowed to be used
   */
  containerImages: (WorkstationContainer | undefined)[];
  /**
   * Machine types that are allowed to be used
   */
  machineTypes: (WorkstationMachineType | undefined)[];
  /**
   * Global URL allow list
   */
  globalURLAllowList: string[];
}
export interface FirewallTag {
  name: string;
  secureTag: string;
}
export interface WorkstationURLList {
  /**
   * URLAllowList is a list of the URLs allowed to access from workstation
   */
  urlAllowList: string[];
  /**
   * DisableGlobalAllowList is a flag to disable the global URL allow list
   */
  disableGlobalAllowList: boolean;
}
export interface WorkstationInput {
  /**
   * MachineType is the type of machine that will be used for the workstation, e.g.:
   * - n2d-standard-2
   * - n2d-standard-4
   * - n2d-standard-8
   * - n2d-standard-16
   * - n2d-standard-32
   */
  machineType: string;
  /**
   * ContainerImage is the image that will be used to run the workstation
   */
  containerImage: string;
}
export interface WorkstationConfigOpts {
  /**
   * Slug is the unique identifier of the workstation
   */
  Slug: string;
  /**
   * DisplayName is the human-readable name of the workstation
   */
  DisplayName: string;
  /**
   * MachineType is the type of machine that will be used for the workstation, e.g.:
   * - n2d-standard-2
   * - n2d-standard-4
   * - n2d-standard-8
   * - n2d-standard-16
   * - n2d-standard-32
   */
  MachineType: string;
  /**
   * ServiceAccountEmail is the email address of the service account that will be associated with the workstation,
   * which we can use to grant permissions to the workstation, e.g.:
   * - Secure Web Proxy rules
   * - VPC Service controls
   * - Login
   */
  ServiceAccountEmail: string;
  /**
   * SubjectEmail is the email address of the subject that will be using the workstation
   */
  SubjectEmail: string;
  /**
   * Annotations are free-form annotations used to persist information
   */
  Annotations: { [key: string]: string};
  /**
   * Map of labels applied to Workstation resources
   */
  Labels: { [key: string]: string};
  Env: { [key: string]: string};
  /**
   * ContainerImage is the image that will be used to run the workstation
   */
  ContainerImage: string;
}
export interface EnsureWorkstationOpts {
  Workstation: WorkstationOpts;
  Config: WorkstationConfigOpts;
}
export interface WorkstationConfigUpdateOpts {
  /**
   * Slug is the unique identifier of the workstation
   */
  Slug: string;
  /**
   * MachineType is the type of machine that will be used for the workstation, e.g.:
   * - n2d-standard-XXX
   * - n2d-highmem-XXX
   */
  MachineType: string;
  /**
   * Annotations are free-form annotations used to persist information
   */
  Annotations: { [key: string]: string};
  /**
   * ContainerImage is the image that will be used to run the workstation
   */
  ContainerImage: string;
  /**
   * Environment variables passed to the container's entrypoint.
   */
  Env: { [key: string]: string};
}
export interface WorkstationConfigDeleteOpts {
  /**
   * Slug is the unique identifier of the workstation
   */
  Slug: string;
  /**
   * NoWait is a flag to indicate if the request should wait for the operation to complete
   */
  NoWait: boolean;
}
export interface WorkstationOpts {
  /**
   * Slug is the unique identifier of the workstation
   */
  Slug: string;
  /**
   * DisplayName is the human-readable name of the workstation
   */
  DisplayName: string;
  /**
   * Labels applied to the resource and propagated to the underlying Compute Engine resources.
   */
  Labels: { [key: string]: string};
  /**
   * Workstation configuration
   */
  ConfigName: string;
}
export interface WorkstationConfigGetOpts {
  Slug: string;
}
export interface WorkstationConfig {
  /**
   * Name of this workstation configuration.
   */
  Slug: string;
  /**
   * The fully qualified name of this workstation configuration
   */
  FullyQualifiedName: string;
  /**
   * Human-readable name for this workstation configuration.
   */
  DisplayName: string;
  /**
   * Annotations are free-form annotations used to persist information
   */
  Annotations: { [key: string]: string};
  /**
   * [Labels](https://cloud.google.com/workstations/docs/label-resources) that
   * are applied to the workstation configuration and that are also propagated
   * to the underlying Compute Engine resources.
   */
  Labels: { [key: string]: string};
  /**
   * Time when this workstation configuration was created.
   */
  CreateTime: string /* RFC3339 */;
  /**
   * Time when this workstation configuration was most recently
   * updated.
   */
  UpdateTime?: string /* RFC3339 */;
  /**
   * Number of seconds to wait before automatically stopping a
   * workstation after it last received user traffic.
   */
  IdleTimeout: any /* time.Duration */;
  /**
   * Number of seconds that a workstation can run until it is
   * automatically shut down. We recommend that workstations be shut down daily
   */
  RunningTimeout: any /* time.Duration */;
  /**
   * ReplicaZones are the zones within a region for which vm instances are created
   */
  ReplicaZones: string[];
  /**
   * The type of machine to use for VM instances—for example,
   * `"e2-standard-4"`. For more information about machine types that
   * Cloud Workstations supports, see the list of
   * [available machine
   * types](https://cloud.google.com/workstations/docs/available-machine-types).
   */
  MachineType: string;
  /**
   * The email address of the service account for Cloud
   * Workstations VMs created with this configuration.
   */
  ServiceAccount: string;
  /**
   * The container image to use for the workstation.
   */
  Image: string;
  /**
   * Environment variables passed to the container's entrypoint.
   */
  Env: { [key: string]: string};
  /**
   * Complete workstation configuration as returned by the Google API.
   */
  CompleteConfigAsJSON: string;
}
export type WorkstationState = number /* int32 */;
export const Workstation_STATE_STARTING: WorkstationState = 1;
export const Workstation_STATE_RUNNING: WorkstationState = 2;
export const Workstation_STATE_STOPPING: WorkstationState = 3;
export const Workstation_STATE_STOPPED: WorkstationState = 4;
export interface Workstation {
  /**
   * Name of this workstation.
   */
  Slug: string;
  /**
   * The fully qualified name of this workstation.
   */
  FullyQualifiedName: string;
  /**
   * Human-readable name for this workstation.
   */
  DisplayName: string;
  /**
   * Indicates whether this workstation is currently being updated
   * to match its intended state.
   */
  Reconciling: boolean;
  /**
   * Time when this workstation was created.
   */
  CreateTime: string /* RFC3339 */;
  /**
   * Time when this workstation was most recently updated.
   */
  UpdateTime?: string /* RFC3339 */;
  /**
   * Time when this workstation was most recently successfully
   * started, regardless of the workstation's initial state.
   */
  StartTime?: string /* RFC3339 */;
  State: WorkstationState;
  /**
   * Host to which clients can send HTTPS traffic that will be
   * received by the workstation. Authorized traffic will be received to the
   * workstation as HTTP on port 80. To send traffic to a different port,
   * clients may prefix the host with the destination port in the format
   * `{port}-{host}`.
   */
  Host: string;
}
export interface WorkstationConfigOutput {
  /**
   * Time when this workstation configuration was created.
   */
  createTime: string /* RFC3339 */;
  /**
   * Time when this workstation configuration was most recently
   * updated.
   */
  updateTime?: string /* RFC3339 */;
  /**
   * Number of seconds to wait before automatically stopping a
   * workstation after it last received user traffic.
   */
  idleTimeout: any /* time.Duration */;
  /**
   * Number of seconds that a workstation can run until it is
   * automatically shut down. We recommend that workstations be shut down daily
   */
  runningTimeout: any /* time.Duration */;
  /**
   * The type of machine to use for VM instances—for example,
   * `"e2-standard-4"`. For more information about machine types that
   * Cloud Workstations supports, see the list of
   * [available machine
   * types](https://cloud.google.com/workstations/docs/available-machine-types).
   */
  machineType: string;
  /**
   * The container image to use for the workstation.
   */
  image: string;
  /**
   * Environment variables passed to the container's entrypoint.
   */
  env: { [key: string]: string};
}
export interface WorkstationOutput {
  slug: string;
  displayName: string;
  /**
   * Creating indicates whether this workstation is currently being created.
   */
  creating: boolean;
  /**
   * Indicates whether the request was considered a duplicate
   */
  duplicateRequest: boolean;
  /**
   * Indicates whether this workstation is currently being updated
   * to match its intended state.
   */
  reconciling: boolean;
  /**
   * Time when this workstation was created.
   */
  createTime: string /* RFC3339 */;
  /**
   * Time when this workstation was most recently updated.
   */
  updateTime?: string /* RFC3339 */;
  /**
   * Time when this workstation was most recently successfully
   * started, regardless of the workstation's initial state.
   */
  startTime?: string /* RFC3339 */;
  state: WorkstationState;
  config?: WorkstationConfigOutput;
  host: string;
}
export interface WorkstationIdentifier {
  Slug: string;
  WorkstationConfigSlug: string;
}
